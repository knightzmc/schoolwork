\documentclass{article}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage{listings}
\usepackage{syntax}
\author{Alexander Wood}
\title{Computer Science Notes}
\begin{document}

\maketitle
  
\tableofcontents


\section{Regular Expressions}
Regular Expressions can be used to validate emails, password, or variables 
and functions in a programming language

\subsection{Control Characters}
\begin{tabular}{|l|l|l|l|l|}
\hline
* & Matches 0 or more times & \verb/ab*c/ & ab, abc, abbbbc \\ \hline
? & Matches 0 or 1 times & \verb/ab?c/ & ac, abc \\ \hline
+ & Matches 1 or more times & \verb/ab+c/ & abc, abbbbc \\ \hline
| & Matches either character & \verb/(a|b)/ & a, b \\ \hline
\end{tabular}



\subsection{BNF Notation}

Regexes can be used to validate simple syntax, but they are not suitable for complex languages.
Context-free languages are used to represent the syntax of languages with complex syntax \textbf{Backus-Naur Form (BNF)} is an example of a context-free language.
\newline
\begin{tabular}{|c|c|} 
\hline
$<$ $>$ & Encloses each element \\ \hline
::= & Defines the rule for a previous element \\ \hline
| & Used to indicate OR \\ \hline
\{ \} & Encloses optional elements \\ \hline
\end{tabular}
\newline

Each element should be broken down until a terminal element is reached. That is,
 an element that can't be broken down any further.

\begin{grammar}
<student-details> ::= <name> <address> <gender>

<address> ::= <street> <town> <county> <post-code>

<gender> ::= "M" | "F"
\end{grammar}

BNF is unambiguous, a statement can only be written in 1 way.
It can also be recursive. For example,
\begin{grammar}
<positiveInteger> ::= <nonZeroDigit>|<digit><positiveInteger>
\end{grammar}


\begin{grammar}
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<whole-number> ::= <digit> | <digit><whole-number>

<plus-minus> ::= + | -

<integer> ::= <whole-number> | <plus-minus> <whole-number>
\end{grammar}

\subsection{Syntax Diagrams}
\includegraphics{syntax diagramn.png}

\subsection{Floating Point}
Floating points are best suited for situations where you need to represent a wide range of values
Whereas fixed-point is best when speed is more important than precision

\begin{itemize}
\item Absolute Error = The difference between the actual number and the rounded number
\item Relative Error = $(x - y) / x$
\end{itemize}
\subsection{Adder Circuits}
The half adder is a circuit used to add 2 binary digits together,
producing a sum and a carry

$1 \oplus 1 = 0$
$1 \& 1 = 1$
so
$1 + 1 = 0 carry 1$

The full adder joins 2 half adders together with an OR gate, to carry forward the last calculation

$A = 0, B = 1, A + B = 0 carry 1$
$0 carry 1 + 0 = 0$
\end{document}
